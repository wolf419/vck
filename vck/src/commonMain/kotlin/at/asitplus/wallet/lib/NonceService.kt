package at.asitplus.wallet.lib

import com.benasher44.uuid.uuid4
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlin.time.Clock
import kotlin.time.Duration
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Instant

/**
 * Provides generation, storage and validation of challenges used throughout the code, e.g. as challenges for
 * presentation of credentials.
 * Can be implemented to provide replication across different instances of the enclosing application.
 */
interface NonceService {

    /**
     * Implementers: Generate a new random string, store it for later verification
     */
    suspend fun provideNonce(): String

    /**
     * Implementers: Verify if the string has been generated by this instance
     */
    suspend fun verifyNonce(it: String): Boolean

    /**
     * Implementers: Verify if the value has been generated by this instance, remove it from the list of valid values
     */
    suspend fun verifyAndRemoveNonce(it: String): Boolean

}

/**
 * Holds valid random values in memory, with all entries having a lifetime of [lifetime],
 * protected with a [Mutex], to ensure a basic form of thread-safety.
 */
class DefaultNonceService(
    val lifetime: Duration = 10.minutes,
    val clock: Clock = Clock.System,
    /** Will check for expired entries when list reaches [sizeToCheckForExpiration] entries */
    val sizeToCheckForExpiration: UInt = 100U,
) : NonceService {

    init {
        require(lifetime > Duration.ZERO) { "lifetime must be > 0" }
    }

    private val mutex = Mutex()

    /** Maps nonce to expiration time. */
    private val map = mutableMapOf<String, Instant>()

    override suspend fun provideNonce() = uuid4().toString().also {
        mutex.withLock {
            map[it] = clock.now() + lifetime
            if (map.size >= sizeToCheckForExpiration.toInt()) {
                cleanupExpiredLocked()
            }
        }
    }

    override suspend fun verifyNonce(it: String) = mutex.withLock {
        map[it]?.let { expiration ->
            if (expiration < clock.now()) {
                map.remove(it)
                false
            } else {
                true
            }
        } ?: false
    }


    override suspend fun verifyAndRemoveNonce(it: String) = mutex.withLock {
        map.remove(it)?.let { entry ->
            entry >= clock.now()
        } ?: false
    }

    private fun cleanupExpiredLocked() {
        map.entries.iterator().let {
            while (it.hasNext()) {
                if (it.next().value < clock.now()) {
                    it.remove()
                }
            }
        }
    }

}